= fastr

Micro web framework for Ruby. Should be used with an EventMachine rack server.

== Guide

The guide is a work in progress, check it out here: http://chrismoos.com/fastr

You can help with the documentation by forking this repository: http://github.com/chrismoos/fastr_doc

== API Documentation

You can see the latest API documentation here: http://rdoc.info/projects/chrismoos/fastr

== Getting Started

  $ sudo gem install fastr
  $ fastr init helloworld
  $ cd helloworld
  $ thin -p 5000 start

== Directory Structure

The directory structure is similar to rails:

* app/(config/controller/views/models)
* public
* lib
* test

== Routes

The routes are configured in app/config/routes.rb

  router.draw do |route|
  	route.for '/:controller/:action'
  	#route.for '/home/:action', :action => '[A-Za-z]+'
  	#route.for '/test', :to => 'home#index'
  end
  
== Settings

Various settings can be configured in app/config/settings.rb

  config.log_level = Logger::DEBUG
  config.cache_templates = true
  
== Controller
  
  class HomeController < Fastr::Controller
    def index
      render(:text, "Hello, world!")
    end
  end
  
= Request/Response Information

== Headers

You can set response headers by accessing the attribute headers:

  self.headers['My-Header'] = 'value'
  
== Cookies

You can read cookies by accessing the attribute cookies:

  puts self.cookies['MY_SESS_COOKIE']
  
Set cookie:

  set_cookie("sess", myuniquekey, {:expires => Time.now + 3600})

== Return a view in a controller

The return for a controller is just a rack response, i.e [200, {"Content-Type" => "text/plain"}, "Hello, World!"]

You can also use the following render methods:

  render(:text, "My text")
  
With HAML, the template is rendered and any instance variables in your controller are available in the template.

  render(:haml, :template => "index") # this searches for index.haml in your app/views/ folder
  
JSON:

  render(:json, {:status => "ok", :message => "done"})

== Deferred Responses

fastr also lets you return a deferred response. This is useful if you want to chunk the response back to the client, or have a long running operation that you want to perform without blocking EventMachine.

The following is an example of a deferred response. It executes a sleep which normally would block EventMachine, but by using response.task, we tell EventMachine to run this code in its internal thread pool and when finished the callback is executed.

The following is an example of a controller action.

  def long_running_task
    defer_response(200, {"Content-Type" => "text/plain"}) do |response|
      puts "in our deferred response...now we can do cool stuff!"
      response.send_data("hey\n")
      
      long_task = proc {
        log.debug "Sleeping for 5 seconds...but this won't block other requests"
        sleep(5)
        log.debug "Finished sleeping, returning response to client."
        return "finished"
      }
      
      callback = proc { |result|
        log.debug "Callback result: #{result}"
        response.send_data("#{result}\n")
        response.succeed
      }
      
      # This is used to get a callback when the request's connection is closed
      response.closed do
        puts "Connection closed."
      end
      
      response.task(long_task, callback)
    end
  end
  
== Plugins

Fastr searches the custom/plugins directory in your application's root directory for loading plugins.

Example structure:

* custom/plugins/my_test/plugin.rb
* custom/plugins/my_test/lib/*.rb

When a plugin is found, the plugin.rb file is loaded. It should contain a module that matches the name of your plugin, ending with the word plugin.

Example:

Directory: my_test

Module name: MyTestPlugin

Here is an example plugin and what is currently supported:

  module MyTestPlugin
    def self.after_boot(app)
      puts "booted: #{app}"
    end

    def self.before_dispatch(app, env)
      env
    end

    def self.after_dispatch(app, env, response)
      response
    end
  end
  
== Static Files

Anything stored in the public folder in your project's root directory will be served as a static file. This directory is checked before the routes. The mime type is set based on the file's extension.

== Change Log

0.3

* Added kqueue/epoll.
* Fixed dependencies.
* Added loading of model and lib directories.
* Added settings file.
* Added controller params.
* Added ability to disable template caching.
* Added closed callback for deferred responses.
* Added static file serving.
* Added JSON rendering.
* Added response headers and cookie handling.
* Added plugins.

== Current Status

Right now just the base is done. The controller supports a very basic render method.

== Note on Patches/Pull Requests
 
* Fork the project.
* Make your feature addition or bug fix.
* Add tests for it. This is important so I don't break it in a
  future version unintentionally.
* Commit, do not mess with rakefile, version, or history.
  (if you want to have your own version, that is fine but bump version in a commit by itself I can ignore when I pull)
* Send me a pull request. Bonus points for topic branches.

== Copyright

Copyright (c) 2010 Chris Moos. See LICENSE for details.
